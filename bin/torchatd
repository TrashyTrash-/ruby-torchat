#! /usr/bin/env ruby
require 'optparse'
require 'torchat'

options = {}

OptionParser.new do |o|
	options[:config] = File.expand_path '~/.torchat/torchat.yml'
	options[:host]   = '127.0.0.1'
	options[:port]   = 11111

	o.on '-c', '--config PATH', 'the path to the config file' do |path|
		options[:config] = path
	end

	o.on '-h', '--host HOST', 'the host to listen on' do |ip|
		options[:host] = ip
	end

	o.on '-p', '--port PORT', 'the port to listen on' do |port|
		options[:port] = port
	end

	o.on '-s', '--ssl KEY:CERT', 'the private key and cert files' do |path|
		options[:ssl] = { key: path.split(':').first, cert: path.split(':').last }
	end
end.parse!

%w[INT KILL].each {|sig|
	trap sig do
		puts 'torchatd stopping, bye'

		EM.stop_event_loop
	end
}

class Torchatd
	class Connection < EventMachine::Protocols::LineAndTextProtocol
		def receive_line (line)
			return if line.lstrip.empty?

			@daemon.process self, line.lstrip
		end

		def send_response (text)
			send_data "#{text.to_s.lstrip}\n"
		end

		def unbind
			@daemon.connections.delete self
		end
	end

	attr_reader   :connections, :host, :port, :ssl
	attr_accessor :profile

	def initialize
		@connections = []

		yield self if block_given?
	end

	def start (host, port, ssl = nil)
		return if @started

		@started = true

		@host = host
		@port = port
		@ssl  = ssl

		@signature = EM.start_server host, port, Connection do |conn|
			@connections << conn

			conn.instance_variable_set :@daemon, self
		end
	end

	def stop
		EM.stop_server @signature

		@started = false
	end

	def process (connection, line)
		command, id, rest = line.split(' ', 3)

		case command.downcase.to_sym
		when :starttls
			if @ssl
				connection.start_tls(private_key_file: @ssl[:key], cert_chain_file: @ssl[:cert])
			else
				connection.start_tls
			end

		when :message
			profile.send_message_to id, rest

		when :status
			connection.send_response profile.buddies[id].status

		when :list
			connection.send_response profile.buddies.keys.join(' ')

		else
			connection.send_response 'UNIMPLEMENTED'
		end
	rescue => e
		Torchat.debug e
	end

	def received (packet)
		if packet.type == :message
			send_everyone "#{packet.from.id} MESSAGE #{packet}"
		elsif packet.type == :status
			send_everyone "#{packet.from.id} STATUS #{packet.to_s}"
		end
	end

	def connected (buddy)
		send_everyone "#{buddy.id} CONNECTED"

		if buddy.client.name
			send_everyone "#{buddy.id} CLIENT #{buddy.client.name} #{buddy.client.version}"
		end
	end

	def disconnected (buddy)
		send_everyone "#{buddy.id} DISCONNECTED"
	end

	def send_everyone (text)
		@connections.each {|connection|
			connection.send_response text
		}
	end
end

EM.run {
	Torchatd.new {|d|
		(d.profile = Torchat.new(options[:config])).start {|s|
			s.on :incoming do |incoming|
				Torchat.debug "incoming connection from #{incoming}"
			end

			s.on :outgoing do |outgoing|
				Torchat.debug "outgoing connection to #{outgoing}"
			end

			s.on :connection do |buddy|
				Torchat.debug "#{buddy.id} connected"
			end

			s.on :verification do |buddy|
				Torchat.debug "#{buddy.id} has been verified"
			end

			s.on :ready do |buddy|
				d.connected buddy
			end

			s.on :disconnection do |buddy|
				Torchat.debug "#{buddy.id} disconnected"

				d.disconnected buddy
			end

			s.on :message do |packet|
				d.received packet
			end

			s.on :status do |packet|
				d.received packet
			end
		}
	}.start(options[:host], options[:port], options[:ssl])

	puts 'torchatd started'
}
